from __future__ import annotations

import dataclasses
import io
import os
import typing as t

import numpy as np
import pandas as pd

DEFAULT_METADATA = [
    "4300\r\n",
    "5300\r\n",
    '"                                                                "\r\n',
    "0\r\n",
    "0\r\n",
    "0\r\n",
    '"                                                                                                                                                                                                                                                                "\r\n',
    "501\r\n",
    '"no data"\r\n',
    '"no data"\r\n',
    '"no data"\r\n',
    '"no data"\r\n',
    '"no data"\r\n',
    '"no data"\r\n',
    '"no data"\r\n',
    '"no data"\r\n',
    '"no data"\r\n',
    '"no data"\r\n',
]


def read_file(filepath_or_buffer: os.PathLike[str] | io.BufferedIOBase) -> CWPLData:
    """
    Reads a file of data generated by HR320.

    Parameters
    ----------
    filepath_or_buffer : os.PathLike[str] | io.BufferedIOBase
        The path to a raw binary or buffer from u8167.

    Returns
    -------
    tlab_analysis.cwpl.CWPLData
        A CWPLData object from the file.

    Raises
    ------
    ValueError
        If `filepath_or_buffer` is invalid.

    Examples
    --------
    >>> data = read_file("data.img")  # doctest: +SKIP
    """
    if isinstance(filepath_or_buffer, (str, os.PathLike)):
        with open(filepath_or_buffer, "rb") as f:
            return _read_file(f)
    elif isinstance(filepath_or_buffer, io.BufferedIOBase):
        return _read_file(filepath_or_buffer)
    else:
        raise ValueError(
            "The type of filepath_or_buffer must be os.PathLike or io.BufferedIOBase"
        )


def _read_file(file: io.BufferedIOBase) -> CWPLData:
    metadata = [file.readline().decode(CWPLData.HR320.encoding) for _ in range(18)]
    df = pd.read_csv(
        file,
        header=0,
        encoding=CWPLData.HR320.encoding,
        usecols=[1, 2],
        names=["grating", "intensity"],
        quotechar="'",
    )
    data = CWPLData(df, metadata)
    return data


@dataclasses.dataclass(frozen=True)
class CWPLData:
    """
    Data class for continuous wave photo luminescence measurements.

    Examples
    --------
    Create dataframe of data.
    >>> grating = np.arange(4000, 4500)
    >>> np.random.seed(0)
    >>> intensity = np.random.random(grating.size)
    >>> df = pd.DataFrame(
    ...     dict(
    ...             grating=grating,
    ...             intensity=intensity,
    ...     )
    ... )

    Create a CWPLData object.
    >>> data = CWPLData(df)
    >>> data.df
        grating  intensity
    0       4000   0.548814
    1       4001   0.715189
    2       4002   0.602763
    3       4003   0.544883
    4       4004   0.423655
    ..       ...        ...
    495     4495   0.271653
    496     4496   0.455444
    497     4497   0.401714
    498     4498   0.248413
    499     4499   0.505866

    [500 rows x 2 columns]

    Access each column.
    >>> data.grating
    0      4000
    1      4001
    2      4002
    3      4003
    4      4004
        ... 
    495    4495
    496    4496
    497    4497
    498    4498
    499    4499
    Name: grating, Length: 500, dtype: int64
    >>> data.intensity
    0      0.548814
    1      0.715189
    2      0.602763
    3      0.544883
    4      0.423655
            ...   
    495    0.271653
    496    0.455444
    497    0.401714
    498    0.248413
    499    0.505866
    Name: intensity, Length: 500, dtype: float64

    Get wavelength and caribrated wavelength.
    >>> data.wavelength
    0      400.0
    1      400.1
    2      400.2
    3      400.3
    4      400.4
        ...  
    495    449.5
    496    449.6
    497    449.7
    498    449.8
    499    449.9
    Name: grating, Length: 500, dtype: float64
    >>> data.wavelength_caribrated
    0      386.64700
    1      386.75173
    2      386.85646
    3      386.96119
    4      387.06592
            ...    
    495    438.48835
    496    438.59308
    497    438.69781
    498    438.80254
    499    438.90727
    Name: grating, Length: 500, dtype: float64
    """

    df: pd.DataFrame
    """A dataframe of the measurement."""
    metadata: list[str] = dataclasses.field(
        default_factory=lambda: list(DEFAULT_METADATA)
    )
    """Meta information of the data from HR320."""

    @dataclasses.dataclass(frozen=True)
    class HR320:
        encoding: str = "cp932"

    def __eq__(self, __o: object) -> bool:
        if isinstance(__o, CWPLData):
            return all(
                (
                    (self.df == __o.df).all(axis=None),
                    self.metadata == __o.metadata,
                )
            )
        else:
            return NotImplemented  # pragma: no cover

    @property
    def wavelength(self) -> pd.Series[t.Any]:
        """
        A series of wavelength in nanometer.
        """
        return self.grating / 10

    @property
    def wavelength_caribrated(self) -> pd.Series[t.Any]:
        """
        A series of caribrated wavelength in nanometer.
        """
        return 1.0473 * self.wavelength - 32.273

    @property
    def grating(self) -> pd.Series[t.Any]:
        """
        A series of grating in 10 × nanometer.
        """
        column_name = "grating"
        assert (
            column_name in self.df.columns
        ), f"The column named `{column_name}` doesn't exist in CWPLData.df"
        return self.df[column_name]

    @property
    def intensity(self) -> pd.Series[t.Any]:
        """
        A series of intensity in arbitrary units.
        """
        column_name = "intensity"
        assert (
            column_name in self.df.columns
        ), f"The column named `{column_name}` doesn't exist in CWPLData.df"
        return self.df[column_name]

    def to_raw_binary(self) -> bytes:
        """
        Converts to a raw binary that HR320 generates.

        Returns
        -------
        bytes
            A raw binary that HR320 generates.
        """
        df = pd.DataFrame(
            {
                "": None,
                "x (cm)": self.grating.map(lambda x: "{0:.3f}".format(x)),
                "強度1 (mv)": self.intensity.map(lambda x: "{0:.4E}".format(x)),
                "強度2 (mV)": pd.Series(np.zeros(self.grating.size)).map(
                    lambda x: "{0:.4E}".format(x)
                ),
            }
        )
        raw_binary = (
            "".join(self.metadata)
            + "".join(
                f'"{line}"\r\n'
                for line in df.to_csv(
                    index=False,
                ).splitlines()
            )
        ).encode(self.HR320.encoding)
        return raw_binary
